const fs = require('fs')
const tmp = require('tmp')

const cheerio = require('cheerio')
const $ = cheerio

const ComponentConverter = require('../component/ComponentConverter')
const pandoc = require('../helpers/pandoc')

/**
 * Markdown converter for the `Document` class
 *
 * Uses Pandoc to convert to/from Markdown. Currently, Github Flavored Markdown
 * is assumed for loading and dumping.
 */
class DocumentMarkdownConverter extends ComponentConverter {

  /**
   * Load a document from Markdown
   *
   * @param  {Document} document Document to load
   * @param  {[type]} content  Markdown content
   * @param  {[type]} format   Format (usually `md`)
   * @param  {[type]} options  Any options (see implementations for those available)
   */
  load (document, content, format, options) {
    options = options || {}

    // Mapping of format to Pandoc reader
    format = {
      'md': 'markdown_github+yaml_metadata_block+implicit_figures+bracketed_spans+backtick_code_blocks+fenced_code_attributes+definition_lists'
    }[format || 'md'] || format

    // To extract the document's meta-data use a custom Pandoc template.
    // See
    //   http://pandoc.org/MANUAL.html#templates
    //   https://github.com/jgm/pandoc-templates/blob/master/default.html5
    // Note that `$abstract$` can be one or more paragraph if that is ow it is written in YAML
    let template = tmp.tmpNameSync({postfix: '.txt'})
    fs.writeFileSync(template, `$if(title)$
<h1 id="title">$title$</h1>
$endif$
$if(subtitle)$
<p id="subtitle">$subtitle$</p>
$endif$
$for(author)$
<p class="author">$author$</p>
$endfor$
$if(date)$
<p id="date">$date$</p>
$endif$
$if(abstract)$
<div id="summary">$abstract$</div>
$endif$
$if(toc)$
<nav id="toc">$toc$</nav>
$endif$
$body$`)

    let html = pandoc.convert(content, format, null, {
      'template': template,
      'no-highlight': null
    })

    document.content = cheerio.load(html)

    // Transform Pandoc generated HTML to "Stencila HTML5" (i.e. the HTML structure
    // that Stencila expects)

    // Convert HTML generated by the Pandoc extension `implicit_figures` to HTML5:
    //    md:             ![Caption](figure.png)
    //    pandoc html:    <div class="figure"><img src="figure.png"><p class="caption">Caption</p></div>
    //    stencila html:  <figure><img src="figure.png?raw">\n  <figcaption>Caption</figcaption>\n</figure>
    document.content('div.figure').each(function () {
      let el = $(this)
      el.removeClass('figure')
      if (el.attr('class') === '') el.removeAttr('class')
      el.find('p.caption').toArray().forEach(el => {
        el.name = 'figcaption'
        el = $(el)
        el.removeClass('caption')
        if (el.attr('class') === '') el.removeAttr('class')
      })
      this.name = 'figure'
    })

    // We use the Pandoc extension `backtick_code_blocks` to define a Markdown syntax
    // for execute directives:
    //    md:             ```a=r(b,c)
    //    pandoc html:    <pre class="a=r(b,c)"><code>...
    //    stencila html:  <pre data-execute="r" data-output="a" data-input="b,c">...
    document.content('pre[class] code').each(function () {
      let code = $(this)
      let pre = code.parent()
      let clas = pre.attr('class')
      let matches = clas.match(/(([\w_]+) *= *)?(\w+)\(([^(]*)\)( *\{([^}]*)\})?/)
      if (matches) {
        pre.removeAttr('class')
        pre.attr('data-execute', matches[3])
        if (matches[1]) pre.attr('data-output', matches[2])
        if (matches[4]) pre.attr('data-input', matches[4])
        if (matches[6]) {
          for (let option of matches[6].trim().split(' ')) {
            let parts = option.trim().split('=')
            if (parts.length === 2) {
              pre.attr('data-' + parts[0].trim(), parts[1].trim())
            }
          }
        }
        let text = code.text()
        pre.empty()
        pre.text(text)
      }
    })

    // We use the Pandoc extension `bracketed_spans` with a name option to define a Markdown syntax
    // for inputs:
    //    md:             [45]{name=a}
    //    pandoc html:    <span name="a">45</span>
    //    stencila html:  <input name="a" value="45">
    // and for inputs of type 'select':
    //    md:             [nashi]{name=a type=select apple=Apple nashi="Nashi Pear" pear=Pear}
    //    pandoc html:    <span name="a" type=select apple="Apple" nashi="Nashi Pear" pear="Pear">nashi</span>
    //    stencila html:  <select name="a"><option>....</select>
    document.content('span[name]').each(function () {
      let $this = $(this)
      let clas = $this.attr('class')
      if (!clas || clas === 'input') {
        let type = $this.attr('type') || 'text'
        if (type === 'select') {
          this.name = 'select'
          let selected = $this.text()
          $this.empty()
          $this.removeAttr('type')
          for (let attr in $this.attr()) {
            if (['name', 'type', 'class'].indexOf(attr) < 0) {
              let $option = $('<option>')
              $option.attr('value', attr)
              let value = $this.attr(attr)
              $option.text(value)
              if (attr === selected) $option.attr('selected', true)
              $this.append($option)
              $this.removeAttr(attr)
            }
          }
        } else {
          this.name = 'input'
          $this.attr('value', $this.text())
          $this.empty()
        }
      }
    })

    // We use the Pandoc extension `bracketed_spans` with a value option to define a Markdown syntax
    // for outputs:
    //    md:             []{value=a format="%.2d"}
    //    pandoc html:    <span value="a" format="%.2d">45</span>
    //    stencila html:  <output for="a" data-format="%.2d">
    // Note that we have already removed inputs spans with a `name` option above
    document.content('span[value]').each(function () {
      let $this = $(this)
      let clas = $this.attr('class')
      if (!clas || clas === 'output') {
        this.name = 'output'
        let value = $this.attr('value')
        $this.removeAttr('value')
        $this.attr('for', value)
        let format = $this.attr('format')
        if (format) {
          $this.removeAttr('format')
          $this.attr('data-format', format)
        }
      }
    })

    // Include directives. Paragraphs beginning with `<` and `definition_lists` extension for modifiers where
    // definition term begins with `&`
    document.content('p').each(function () {
      let $this = $(this)
      let text = $this.text()
      if (text[0] === '<') {
        let match = text.match(/< *([^ (]+) *([^(]+)? *(\(([^)]+)\))?/)
        if (match) {
          this.name = 'div'
          $this.empty()
          let address = match[1]
          if (address) $this.attr('data-include', address)
          let selector = match[2]
          if (selector) $this.attr('data-select', selector.trim())
          let input = match[4]
          if (input) $this.attr('data-input', input)

          let $next = $this.next()
          if ($next.is('dl')) {
            $next.children().each(function () {
              let $child = $(this)
              if ($child.is('dt')) {
                let text = $child.text()
                if (text[0] === '&') {
                  let match = text.match(/& *([^ ]+) *(.+)?/)
                  if (match) {
                    let $next = $child.next()
                    if ($next.is('dd')) {
                      $next[0].name = 'div'
                      $next.attr('data-' + match[1], match[2])
                    }
                    $this.append($next)
                  }
                }
              }
            })
            $next.remove()
          }
        }
      }
    })
  }

  /**
   * Dump a document to Markdown
   *
   * Leading and trailing whitespace, including newlines, are trimmed
   *
   * @param  {Document} document Document to dump
   * @param  {String} format   Format ( usually `md`)
   * @param  {Object} options  Any options (see implementations for those available)
   * @return {String}          Content of the document as Commonmark
   */
  dump (document, format, options) {
    options = options || {}
    let html = document.dump('html')
    return pandoc.convert(html, 'html', 'commonmark', {
      'wrap': options.wrap || 'preserve',
      'columns': options.columns || 100
    }).trim()
  }

}

module.exports = DocumentMarkdownConverter
