const DocumentMarkdownConverter = require('./DocumentMarkdownConverter')
const pandoc = require('../helpers/pandoc')

/**
A Document converter for XMarkdown.

XMarkdown is our name for RMarkdown-like formats, that is, RMarkdown but extended to language
X, where X includes Python, Javascript, etc.

In RMarkdown, R code is embedded in "code chunks". There are two types of code chunks: inline and block.
In XMarkdown, we allow both inline and block chunks to be defined in various languages using
our usual language labels e.g. ``r``, ``py``, ``js``.

Inline code chunks, equivalent to Stencila's print directive, are declared using Markdown code spans
prefixed by the language label e.g.

    The answer is `r x`

Block code chunks, equivalent to Stencila's execute directive, are declared using Markdown fenced code blocks
with attributes prefixed by the language label and, optionally, a chunk label and other options e.g.

    ```{r myplot, fig.width=6, fig.height=7}
    plot(x,y)
    ```

Here ``myplot`` is the chunk label and ```fig.width=6, fig.height=7``` are chunk options.
A list of chunk options, recognised by the RMarkdown rendering enging, Knitr,
is available at http://yihui.name/knitr/options/.
For RMarkdown documents, to maintain compatability with Knitr, options are converted to
Stencila execute directive settings as follows

- eval=FALSE : do FALSE
- echo=TRUE : show TRUE
- fig.height=6 : height 6
- fig.width=7 : width 7

**/
class DocumentXMarkdownConverter extends DocumentMarkdownConverter {

  load (document, content, format, options) {
    options = options || {}
    let html = pandoc.convert(content, 'markdown', 'html')
    document.load(html, 'html')
  }

  dump (document, format, options) {
    options = options || {}

    // let lang = format.substring(0, format.length - 2)

    let html = document.dump('html')
    let md = pandoc.convert(html, 'html', 'markdown', {
      'wrap': options.wrap || 'preserve',
      'columns': options.columns || 100
    })

    // Postprocess Markdown generated by Pandoc to convert it to XMarkdown
    let xmd = ''
    md.split('\n').forEach((line) => {
      // let match = line.match('^```\\s*{(#([\\w\\-\\.]+)\\s+)?\\.(' + lang + ')(\\s+[^}]+?)?}\\s*$/')
      xmd += line + '\n'
      /*
      if match:
          xmd += '``` {' + match.group(3)
          label = match.group(2)
          if label:
              xmd += ' ' + label
          attrs = match.group(4)
          if attrs:
              options = []
              for attr in attrs.split():
                  attr = attr.strip()
                  match = attr_re.match(attr)
                  if match:
                      name, value = match.groups()
                      assert value[0] == '"' and value[len(value)-1] == '"'
                      value = value[1:-1]
                      options.append('%s=%s' % (name, value))
                  else:
                      raise RuntimeError('Unmatched attribute:\n  attr: ' + attr)
              xmd += ', ' + ', '.join(options)
          xmd += '}\n'
      else:
          xmd += line + '\n'
      */
    })
    return xmd
  }

}

module.exports = DocumentXMarkdownConverter
